* Sistemas digitais *

Computadores são aparelhos eletrônicos que recebem, processam, produzem e armazenam informações. Computador vem do verbo "computar" que significa calcular e uma dessas primeiras máquinas era o ábaco, um instrumento de origem chinesa.

Jhon Napier no século XVII foi um dos responsáveis pela régua de cálculo, considerada o primeiro instrumento analógico de contagem, a mãe das calculadoras modernas. Para alguns autores a primeira máquina automática foi inventada pelo francês Blaise Pascal, 1642. A primeira calculadora portátil capaz de realizar as quatro operações e a raiz quadrada foi criada pelo alemão Gottfried Wilhelm Leibniz, que criou um sistema de númeração binário conhecido como a Roda de Leibniz.

A Primeira máquina programável foi um tipo de tear usando cartões perfurados (Joseph-Marie Jacquard).

George Boole criou a álgebra booleana; em seguida no século XIX o inglês Charles Babbage criou a máquina analítica, mais próxima dos computadores atuais pois tinha memória e programas.

https://www.diferenca.com/evolucao-dos-computadores/#:~:text=Cada%20gera%C3%A7%C3%A3o%20de%20computadores%20refere,e%20produzida%20em%20larga%20escala.


Toda a história da computação é divida em gerações:

* Primeira Geração (1940–1956) - Válvulas termiônicas, código de máquina, grandes dimensões, alto consumo de energia, dados inseridos por cartões perfurados (ENIAC, Univac)

* Segunda Geração (1956–1963) - Diodos Transistores, código de montagem, menores dimensões, peso de até 750 kg (PDP-1)

* Terceira Geração (1964–1971) - Circuitos integrados, COBOL, FORTAN, Pascal, C, Basic; criação dos sistemas operacionais, entrada de dados por dispositivos periféricos (IBM 360, UNIVAC 1108)

* Quarta Geração (1971 — presente) - Microprocessadores, JavaScript Python, Java, C#, Kotlin, Microcomputadores , Computadores portáteis, Memoria RAM e ROM, entrada de dados por dispositivos periféricos (Apple Machintosh, IBM-286, IBM-386)

* Quinta Geração (presente-futuro) - Inteligência artificial, computadores quânticos, nanotecnologia, multiprocessadores, linguagem de alto nível, linguagem natural, portáteis, leves, maior velocidade, maior memória, reconhecimento de linguagem natural, reconhecimento facial e de voz (Laptops, Smartphones, Computadores Quânticos)

----------------------------------------------------------- // -----------------------------------------------------------

* Sistemas Digitais *

Definidos como circuitos eletrônicos que usam sinais elétricos em dois níveis de tensão, constituindo assim uma representação binária, circuitos lógicos; os impulsos elétricos transportados por esses circuitos são chamados de sinais digitais ou binários)

* Sinal analógico e sinal digital

Sinal digital pode assumir dois estados lógicos, como: ligado/ desligado, alto/ baixo, etc. O sinal digital tem algumas vantagens sobre o analógico, são mais imunes a distorções, ruídos e interferências, mais confiáveis e robustos, mais fáceis de projetar e mais baratos e sua implementação de hardware em circuitos é mais flexível.

Grandezas digitais (bit > nibble > byte > word) (1 byte = 8 bits, 1 kilobyte 19 (KB) = 1024 bytes, 1 megabyte (MB) = 1024 kilobytes)

Integração Hardware/ Software (físico e digital)

Dispositivos de entrada - são todos cuja a interação do usuário direciona a informação para dentro do computador.

Dispositivos de saída - são todos aqueles destinados a exibir/receber o resultado do processamento de informações, ou seja, o fluxo é de dentro para fora do computador.

Dispositivos de entrada/saída – Existem dispositivos que podem executar operações tanto de entrada quanto de saída. Como exemplo tem-se o pen drive, que pode ser utilizado para receber arquivos contidos no computador e/ou para transportar arquivos para dentro do computador.

----------------------------------------------------------- // -----------------------------------------------------------

* Tipos de Software *

Software é uma coleção de dados, programas, procedimentos, instruções e documentação que executa várias tarefas predefinidas. A intermediação entre usuário e computador.

Software de Sistema (SO): o software responsável pelo gerenciamento do hardware.

Software de Aplicação: os softwares de aplicação são aqueles programas desenvolvidos para o usuário final.

Conceitos de redes de computadores (trabalho realizado em vários computadores separados porém interligados entre si. 

Endereço IP

Para que haja conectividade (Internet) todos os equipamentos que se conectam precisam de um identificador único dentro da rede local denominado endereço de Internet, endereço IP (Internet protocol).

----------------------------------------------------------- // -----------------------------------------------------------

*Programação de computadores: fundamentos, código, compiladores, código de máquina *


			* Fundamentos *

Programação de computadores é projetar, desenvolver e construir um programa executável, para cumprir uma tarefa ou uma resposta para um determinado resultado;

Programar computadores exige o cumprimento de tarefas, como análises, geração de algoritmos, análise de recursos computacionais, implementação e testes de algoritmos em uma linguagem de programação escolhida, este último processo é comumente conhecido como codificação;

Um programa de computador é um conjunto de instruções e algoritmos;

Um programa de computador é criado, compilado e executado;

As primeiras linguagens de programação se baseavam em instruções descritas com sequências de bytes (instruções binárias);

Em 1950, a linguagem de programação comumente usada era o Assembly, mas, por ser uma linguagem de baixo nível (difícil para um ser humano entender e “visualizar” o código), começaram a surgir linguagens de alto nível, permitindo códigos mais complexos, como Cobol.

- A primeira imagem vista neste conteúdo foi a da programadora Margaret Hamilton, que criou o código de navegação e pouso da missão Apollo para que houvesse pouso com segurança na Lua. Todo aquele código visto na imagem foi escrito em Assembly! -

Toda linguagem de programação tem palavras reservadas, que representam determinadas funções dentro do alfabeto dessa linguagem.

* Compiladores e código de máquina *
Os compiladores transformam uma linguagem de alto nível para um nível mais baixo, para que a máquina possa executar. Compiladores em sua maioria não passam o código direto para binário, mas sim para outra linguagem de baixo nível, como Assembly. Existe uma correlação entre abstração e velocidade entre os níveis de linguagem de programação.

 * Lógica proposicional e lógica booleana *

"... A lógica proposicional se baseia no conceito de proposições, uma sentença declarativa (expressa por palavras ou símbolos) cujo valor pode ser considerado verdadeiro ou falso (e nenhum outro diferente desses)... "

Uma proposição verdadeira é verdadeira; uma proposição falsa é falsa (princípio da identidade).

Nenhuma proposição poderá ser verdadeira e falsa ao mesmo tempo. (princípio da não contradição).

Uma proposição ou será verdadeira, ou será falsa: não há outra possibilidade (princípio do terceiro excluído).


* Conectivos *

Conjunção (e) - define que uma expressão é verdadeira quando ambas as proposições são verdadeiras. (símbolo ∧)

Disjunção (ou) - define que uma das proposições será verdadeira se alguma das proposições for verdadeira (símbolo ∨)


Pensamento computacional: decomposição, reconhecimento de padrões, abstração e algoritmos

Pensamento computacional (quebrar problemas, reconhecer padrões, abstrair e desenhar passos de regras para solucioná-los.)
Algoritmos são separados em pequenos passos:

Decomposição: separação de atividades de um problema, separadas em "n" passos.

Reconhecimento de padrões: atividades rotineiras em mais de um passo.

Abstração: separação do que é essencial e secundário nas atividades.

Algortimo: literalmento o passo a passo a ser seguido.

----------------------------------------------------------- // -----------------------------------------------------------

* Metodologias de desenvolvimento de software *

"... não existe uma solução que atenda a todos os tipos de projetos e necessidades."

A metodologia mais tradicional é o modelo cascata:

Análise e definição de requisitos------v
							Projeto de sistemas e de software------v
														Implementação e teste de unidades------v
																					Integração e teste de sistemas------v
																											Operação e manutenção


Modelo de etapas prederminadas, executadas sequencialmente. Finalizando uma para iniciar a outra. Levantamento de dados, projeto, implementação, realização de testes e manutenção do sistema.

----------------------------------------------------------- // -----------------------------------------------------------

* Metodologias ágeis *

"...  surgem como uma proposta de atender com flexibilidade e agilidade às características do mercado corporativo nos dias de hoje."

Sua base é funcionar com pequenas entregas para que seja avaliada a evolução de cada passo, sendo assim possível redirecionar o projeto em andamento.



* Scrum *


			* Artefatos do scrum *

*Milestone* é um agrupamento de atividades similares.

(Nesse tipo de projeto, validar um conceito é conhecido como “prova de conceito” e utiliza-se a sigla POC (originada do termo em inglês proof of concept, que, traduzindo do inglês, significa “prova de conceito”).

*User story* é um artefato utilizado para descrever objetivos e funcionalidades de um software. Nesse artefato, você responderá “para quem?”, “o quê?” e “por quê?”. Respondendo a essas três perguntas, você conseguirá direcionar o desenvolvimento das atividades, sem definir como as elas devem ser realizadas (dando flexibilidade para a equipe de desenvolvimento do projeto).

e.g:       	Eu, como um médico,
		Quero conseguir registrar os laudos que preenchi
		De modo que consiga acessá-los depois fácil e rapidamente.

*Product backlog* é a nossa lista total de tarefas para o completo desenvolvimento da solução. O Product backlog é responsabilidade do product owner.

*Sprint* "... sprint como uma janela de tempo, na qual a equipe planejará quais atividades serão feitas e qual é o objetivo desse incremento... "

*Sprint backlog* a lista de atividades a serem realizadas em uma sprint.


			* Papéis do scrum *

*Scrum Master* é o líder da equipe scrum, responsável pela execução dos processos, resolução de bloqueios e representar o time scrum, defendendo o projeto e orientando a equpe.

*Product owner* também chamado de PO, "dono do produto", responsável pelo product backlog e suas atividades, ele também valida o andamento do projeto, aprovando as atividades e delegando novas atividades.

*Time de desenvolvimento* são quem executa as tarefas dos scrum.

*Stakeholders* são as pessoas impactadas ou interessadas no projeto, usuários ou matenedores do projeto final.



			* Cerimônias do scrum *


*Planning* reunião para definir os sprints, tamanhos, tempo, sprint backlogs, etc.

*Planning Poker* uma técnica para tentar achar um consenso sobre a estimativa das atividades apresentadas.

*Daily* stand-up meeting, reunião que ocorre todos os dias, de curta duração, em que todos os membros informam brevemente o status de suas atividades e se existe algum bloqueio no seu fluxo de trabalho, informando se precisam de apoio ou orientação. 
"O que eu fiz ontem?", "O que vou fazer hoje?" e "Tenho algum bloqueio?".

*Sprint review" é uma reunião para apresentar os resultados da sprint para o product owner onde o mesmo aprovara a entrega e fazer feedbacks para a equipe. Realizada no final da sprint com todas as atividades finalizadas.

*Sprint retrospective*  reunião junto ao scrum master para analisar a última sprint, seu ponto é debater sobre potenciais pontos de melhoria para otimizar o processo.
SMART (específica, mensurável, atingível, relevante, temporal)


* Kanban *

O kanban é outra metodologia ágil, que usa alguns princípios do scrum, porém não usa sprints, e sim, com um quadro de atividades para representar o fluxo de trabalho.
"para fazer", "fazendo" e "feito"


----------------------------------------------------------- // -----------------------------------------------------------

* Regras de negócio *

Negócio pode ser definido com o que uma organização faz (comercialização de um produto ou a prestação de um serviço). As partes de um negócio podem ser entendidas como etapas ou processos.

Regras de negócio em TI, são processos que diretamente determinam o funcionamento da empresa. Essas regras consolidá-las, é preciso de documentação, avaliação de fluxo de trabalho e análise das necessidades. São as diretrizes básicas dos negócios.

Regras de negócio padrão: o que, onde, quando, por que e como será feito.

Business Process Management (abordagem de gerenciamento adaptával com foco na modelagem de processos. Ela não alcança nunca uma conclusão, pois trata de uma revisão e melhora de etapas constantes.

* Melhora contínua, transparência de processos, organizações mais eficientes.
* Aumento de produtividade, eliminação de processos redundantes.
* Redução de custos.
* Automatização de tarefas.
* Evolução contínua.


* Requisitos funcionais e não funcionais *

"o que fazer" nessa parte entram em ação os requisitos funcionais e não funcionais auxiliaram na meneira pela qual serão atingidos os objetivos principais e secundários. São os requisitos que definem como atingir o objetivo do negócio. Solicitações, desejos e necessidades. Requisitos sendo funções de apoio para que os processos da empresa se realizem, sejam eles manuais ou informatizados.

e.g.

*Empresa de software*

Objetivo Principal:
Ser referência no ramo de desenvolvimento de software.

Objetivos Secundários:
Ter profissionais comprometidos.
Ter uma sede para empresa.
Oferecer sistemas que se adaptem as necessidades do clientes.

Requisito funcional: processo que define o funcionamento percebido do sistema pelos usuários. Problemas, necessidades que são atendidas ou resolvidas pelo software através de funções ou serviços. É o que o software faz. Requisitos funcionais devem ser descritos de forma objetiva e evitando complexidade para que o objetivo seja atingido com qualidade.

Requisito não funcional: qualidades globais do sistema, manutenção, usabilidade, desempenho, custos, etc. Descritos informalmente. São dividos em três categorias: requisitos de produto final, organizacional e externo.

* Requisitos de produto final: ligados ao comportamento do software. Tempo de resposta do sistema, velocidade de execução, conexão, portabilidade, consistência, segurança, taxa de erros e confiabilidade.

* Requisitos organizacionais: relacionados aos padrões da organização, software de acordo com as políticas e definições da empresa. Infraestrutura, sistema operacional compatível, conexão, criptografia usada pela empresa e linguagem de programação requisitada pela empresa.

* Requisitos externos: relacionados a qualquer tipo de agente externo ao software que pode causar impacto no seu funcionamento. Localização geográfica em que o software será usado, legislação, sistemas e política de proteção de dados.

----------------------------------------------------------- // -----------------------------------------------------------

* Técnicas para a extração de requisitos *

Parte importante do desenvolvimento é o levantamento dos requisitos necessários para a seu planejamento e execução. Sommerville (2003), propõe um processo genérico para essa tarefa:

* Compreensão do domínio: domínio da aplicação, compreensão de onde estão as classes que fazem parte da descrição dos problemas.
* Coleta de requisitos: interação com as partes interessadas do sistema, descobrindo assim os requisitos delas.
* Classificação: conjunto não estruturado dos requisitos e a mediante organização em grupos coerentes.
* Resolução de conflitos: múltiplas partes interessadas geram conflitos de requisitos, faze de adaptação e resolução desses conflitos.
* Definição das prioridades: qualquer conjunto de requisitos, alguns serão mais importantes do que outros. Definição de quais são esses.
* Verificação de requisitos: analise para descobrir se os requisitos estão completos, consistente e se estão em concordância.

 "... a extração de requisitos é o processo de transformação das ideias que estão na mente do usuário (entrada) em um documento formal (saída)."

* Processo de extração de requisitos *

* Entendimento do domínio - entendimento dos desenvolvedores do domínio da aplicação como um todo, compreendendo o foco principal.
* Extração e análise de requisitos - descoberta dos requisitos por meio da interação com a parte interessada.
* Especificação dos requisitos - armazenamento dos requisitos em uma ou mais formas, linguagem, simbólicas, gráficas. 
* Validação dos requisitos - confirmação se os requisitos estão de acordo com as necessidades do cliente/usuário.

* Métodos para extração e análise de requisitos *

Podem ser divididos em técnicas formais e informais. Informais são baseadas na comunicação estruturada, interação com usuário, questionários, etc. Comunicações humanas ou de máquinas. "...  método JAD (joint application design), o brainstorming, as entrevistas e a técnica Pieces (desempenho – ou performance –, informação e dados, economia, controle, eficiência e serviços)."

* JAD *

Método de projeto interativo, basea-se en reuniões de grupo nas quais participam os representantes dos envolvidos no projeto, produzindo uma projeção de software.
Proporciona maior produtividade, maior qualidade, trabalho em equipe, custos mais baixos de desenvolvimento e manutenção.

A forma mais produtiva desse trabalho em grupo é obtida através do consenso. Entendo consenso não como unanimidade de opiniões, mas sim, a concordância eentre os participantes de que a solução encontrada é melhor para o grupo e não fere as bases do que se é buscado.

* Facilitador: coordena a sessão JAD.
* Documentador (pode ser um analista ou programador): registra todas as conclusões do grupo.
* Observador (deverá ser uma pessoa perspicaz).
* Indicador de assunto: garante que todos os pontos sejam tratados e deve ser um envolvido no projeto, que conheça bem o assunto.
* Representante dos envolvidos (usuários): representa as áreas envolvidas (devem ser escolhidas as pessoas-chave, independentemente do nível hierárquico).
* Gerente do projeto: deve acompanhar as sessões, uma vez que o sucesso ou o fracasso do projeto será sua responsabilidade.
* Especialista: conhece os projetos da organização, que tenham interface com o projeto em estudo.


* Brainstorming *

Técnica que auxilia a potencializar a criatividade e a encontrar soluções para determinados problemas. Uma reunião, na qual cada participante pode expor suas ideias e sugestões, com total liberdade, além de debater sobre as ideais e sugestões dos demais participantes.


* Método:

* Divulgação clara de objetivos.
* Geração de ideias (entre 20 e 60 minutos).
* Intervalo para relaxamento.
* Estudo detalhado de cada ideia.


* Entrevistas *

Técnica estruturada que pode ser aprendida e na qual os desenvolvedores podem ganhar proficiência com o treino e a prática. A entrevista consiste em quatro fases: identificação dos candidatos para a entrevista, preparação para uma entrevista, condução da entrevista e finalização da entrevista.


* Pieces *

Técnica para os desenvolvedores inexperientes, que apresentam dificuldades em como e o que perguntar para extrair os requisitos do cliente. Pieces ajuda a resolver esses problemas, pois fornece um conjunto de categorias de problemas que auxiliam a estruturação do processo de extração de requisitos.

Em cada categoria existem várias questões que o desenvolvedor deve explorar com o usuário:

* Performance – reflete o que o usuário espera.
* Informação – tipo de acesso às informações (relatório, funções on-line) que inclui a quantidade de informação oferecida pelo software.
* Economia – custo de usar um produto de software, processadores, armazenagem e conexão.
* Controle – restrições de acesso ao sistema, acesso a algumas informações e habilidade de monitorar o comportamento do sistema.
* Eficiência – evitar coletar o mesmo dado mais de uma vez e armazená-lo em espaço múltiplo.
* Serviços – refere-se a que tipo de serviços os usuários necessitam que o software realize.

----------------------------------------------------------- // -----------------------------------------------------------

* UML e diagramas de caso de uso *

A UML (unified modeling language ou linguagem de modelagem) é usada para visualização, especificação, construção, documentação e comunicação. UML define os procedimentos que auxiliam a modelagem e a documentação do software a ser desenvolvido.

Com toda a informação extraída, com todas as demandas definidas, com o entendimento da regra de negócio. Identificados os requisitos funcionais e não funcionais, se obtendo uma ampla visão do sistema. Chega-se na fase de exemplificar isso utilizando uma forma gráfica. Diagramas de caso de uso.

* Diagramas de caso de uso *

"... como os usuários interagem com o sistema (as funcionalidades do sistema), facilita a organização dos requisitos desse sistema e dá a visão externa do sistema. O conjunto de casos de uso deve ser capaz de comunicar ao usuário a funcionalidade e o comportamento do sistema."

Conjunto de símbolos e conectores específicos, afim de ajudar a equipe de desenvolvimento a entender o cenários em que o sistema interage com pessoas ou organizações, identifica metas gerais do sistema, montando o escopo do sistema. Vantagens:

* Representar as metas de interações entre sistemas e usuários.
* Definir e organizar requisitos funcionais no sistema.
* Especificar o contexto e os requisitos do sistema.
* Modelar o fluxo básico de eventos no caso de uso.

* O diagrama de caso de uso é composto de quatro partes:

* Cenário - sequência de eventos que acontecem quando um usuário interage com o sistema.
* Ator - usuário do sistema/ tipo de usuário do sistema.
* Use case - tarefa ou funcionalidade realizada pelo ator (usuário).
* Comunicação - é o que liga o ator com um caso de uso.

----------------------------------------------------------- // -----------------------------------------------------------

* Projeto de software: conceito e etapas *

"... planejamento que é iniciado antes do desenvolvimento de um novo sistema. É por meio desse planejamento que se consegue elaborar uma sequência de eventos com início, meio e fim, definindo aspectos importantes para execução do projeto e controlando o processo de desenvolvimento... "

Projeto --------------------------------------- Processos de planejamento --------------------------------------- 1. Planejar o gerenciamento do escopo do projeto.
                                                                                                                                                                2. Coletar requisitos.
																			         3. Definir o escopo.
																				  4. Criar EAP.
                                                               Processos de monitoramento e controle  ---------------------- 5. Validar o escopo.
																		                6. Controlar o escopo.

Cada uma dessas etapas pode gerar documentos úteis, que posteriormente serão utilizados como guias, gerando uma base de informações e ações a serem seguidas no desenvolvimento. 

* Etapas de desenvolvimento * 

1.  Planejar o gerenciamento do escopo do projeto:  processo inicial do projeto. Nessa etapa que serão definidas informações mais amplas da ideia do projeto, o que o cliente deseja, de que modo será organizado, que tipo de ferramentas de controle serão utilizadas, quais serão os integrantes que pertencerão ao projeto, como o cliente validará o progresso do desenvolvimento, entre outros. Nessa fase, tem-se como resultado documentos como o Termo de abertura do projeto e o Plano de gerenciamento do projeto.

2. Coletar os requisitos: considerada como parte do planejamento, se da obtenção das características e funções que o cliente deseja para o software. Por meio dessa atividade será gerada a documentação de requisitos.

3. Definir o escopo: a definição de escopo é como uma sequência direta do processo de coletar os requisitos, porém, de uma forma mais detalhada, delimitando com precisão o que será ou não feito no sistema

4. Criar a EAP (estrutura analítica do projeto): realização do processo de subdividir entregas em componentes menores. Utilizando como base os documentos gerados nas fases anteriores.

5. Validar o escopo: monitoramento e controle. Formalizar a aceitação das entregas concluídas do projeto. Testar as funcionalidades prontas. Essa etapa funciona como uma inspeção das atividades realizadas, confirmando o sucesso no desenvolvimento e observando o desempenho do trabalho de forma geral. Alterações nessa fase do projeto deve gerar também alterações nos documentos correspondentes.

6. Controlar o escopo: monitoramento do andamento do projeto, do produtos e das mudanças que aconteceram ao longo do desenvolvimento. Verificação se o trabalho está correndo de acordo com o cronograma definido. 

* Ciclo de vida do software *

"... é uma ordem de acontecimentos dos processos e das atividades que fazem parte do desenvolvimento."


Fase de requisitos ----> Fase de projeto  ----> Fase da implementação  ----> Fase de testes  ----> Fase de produção

* Fase de requisitos (contato primário com o problema, análise, levantamento de requisitos);
* Fase de projeto (geração do protótipo, atributos, funções, estruturas, classes, objetos, segmentos, as relações entre partes do sistema);
* Fase da implementação (fase mais longo, implementação, codificação do sistema em si);
* Fase de testes (validação dos requisitos);
* Fase de produção (apresentação do resultado final, instalção no ambiente do usuário, importação de dados do cliente, corrigir problemas e até tirar dúvidas)

* caixa-branca e caixa-preta: caixa-branca baseia-se no conhecimento da estrutura do programa, tendo acesso ao código fonte. Os testes são executados via código, fluxo de controle, fluxo de dados, funções, etc. Caixa-preta baseia-se na visão do usuário, considerando a falta de acesso ao código-fonte. Os testes são derivados das especificações definidas ao sistema. *


* Riscos de projeto *

Falta de monitoramento sistemático do projeto, má-comunicação entre a equipe e o gerente de projetos, falta de gestão de riscos, falta de comunicação com o cliente. São alguns exemplos de riscos ao projeto.

----------------------------------------------------------- // -----------------------------------------------------------